{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { createMat4 } from './math-utils';\nimport { worldToPixels, pixelsToWorld } from './web-mercator-utils';\nimport * as mat4 from 'gl-matrix/mat4';\nvar IDENTITY = createMat4();\n\nvar Viewport = function () {\n  function Viewport() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        width = _ref.width,\n        height = _ref.height,\n        scale = _ref.scale,\n        _ref$viewMatrix = _ref.viewMatrix,\n        viewMatrix = _ref$viewMatrix === void 0 ? IDENTITY : _ref$viewMatrix,\n        _ref$projectionMatrix = _ref.projectionMatrix,\n        projectionMatrix = _ref$projectionMatrix === void 0 ? IDENTITY : _ref$projectionMatrix;\n\n    _classCallCheck(this, Viewport);\n\n    this.width = width || 1;\n    this.height = height || 1;\n    this.scale = scale;\n    this.unitsPerMeter = 1;\n    this.viewMatrix = viewMatrix;\n    this.projectionMatrix = projectionMatrix;\n    var vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    var m = createMat4();\n    mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, this.viewProjectionMatrix);\n    var mInverse = mat4.invert(createMat4(), m);\n\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  _createClass(Viewport, [{\n    key: \"equals\",\n    value: function equals(viewport) {\n      if (!(viewport instanceof Viewport)) {\n        return false;\n      }\n\n      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);\n    }\n  }, {\n    key: \"project\",\n    value: function project(xyz) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$topLeft = _ref2.topLeft,\n          topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft;\n\n      var worldPosition = this.projectPosition(xyz);\n      var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n      var _coord = _slicedToArray(coord, 2),\n          x = _coord[0],\n          y = _coord[1];\n\n      var y2 = topLeft ? y : this.height - y;\n      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    }\n  }, {\n    key: \"unproject\",\n    value: function unproject(xyz) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref3$topLeft = _ref3.topLeft,\n          topLeft = _ref3$topLeft === void 0 ? true : _ref3$topLeft,\n          targetZ = _ref3.targetZ;\n\n      var _xyz = _slicedToArray(xyz, 3),\n          x = _xyz[0],\n          y = _xyz[1],\n          z = _xyz[2];\n\n      var y2 = topLeft ? y : this.height - y;\n      var targetZWorld = targetZ && targetZ * this.unitsPerMeter;\n      var coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n\n      var _this$unprojectPositi = this.unprojectPosition(coord),\n          _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3),\n          X = _this$unprojectPositi2[0],\n          Y = _this$unprojectPositi2[1],\n          Z = _this$unprojectPositi2[2];\n\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    }\n  }, {\n    key: \"projectPosition\",\n    value: function projectPosition(xyz) {\n      var _this$projectFlat = this.projectFlat(xyz),\n          _this$projectFlat2 = _slicedToArray(_this$projectFlat, 2),\n          X = _this$projectFlat2[0],\n          Y = _this$projectFlat2[1];\n\n      var Z = (xyz[2] || 0) * this.unitsPerMeter;\n      return [X, Y, Z];\n    }\n  }, {\n    key: \"unprojectPosition\",\n    value: function unprojectPosition(xyz) {\n      var _this$unprojectFlat = this.unprojectFlat(xyz),\n          _this$unprojectFlat2 = _slicedToArray(_this$unprojectFlat, 2),\n          X = _this$unprojectFlat2[0],\n          Y = _this$unprojectFlat2[1];\n\n      var Z = (xyz[2] || 0) / this.unitsPerMeter;\n      return [X, Y, Z];\n    }\n  }, {\n    key: \"projectFlat\",\n    value: function projectFlat(xyz) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n      return xyz;\n    }\n  }, {\n    key: \"unprojectFlat\",\n    value: function unprojectFlat(xyz) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n      return xyz;\n    }\n  }]);\n\n  return Viewport;\n}();\n\nexport { Viewport as default };","map":{"version":3,"sources":["../../src/viewport.js"],"names":["IDENTITY","createMat4","Viewport","width","height","scale","viewMatrix","projectionMatrix","vpm","mat4","m","mInverse","viewport","xyz","topLeft","worldPosition","coord","worldToPixels","x","y","y2","targetZ","z","targetZWorld","pixelsToWorld","X","Y","Z","Number"],"mappings":"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","sourcesContent":["// View and Projection Matrix management\n\nimport {createMat4} from './math-utils';\nimport {worldToPixels, pixelsToWorld} from './web-mercator-utils';\n\nimport * as mat4 from 'gl-matrix/mat4';\n\nconst IDENTITY = createMat4();\n\nexport default class Viewport {\n  /**\n   * @classdesc\n   * Manages coordinate system transformations for deck.gl.\n   *\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   *\n   * @class\n   * @param {Object} opt - options\n   * @param {Boolean} mercator=true - Whether to use mercator projection\n   *\n   * @param {Number} opt.width=1 - Width of \"viewport\" or window\n   * @param {Number} opt.height=1 - Height of \"viewport\" or window\n   * @param {Array} opt.center=[0, 0] - Center of viewport\n   *   [longitude, latitude] or [x, y]\n   * @param {Number} opt.scale=1 - Either use scale or zoom\n   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)\n   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)\n   * @param {Number} opt.altitude= - Altitude of camera in screen units\n   *\n   * Web mercator projection short-hand parameters\n   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)\n   */\n  // eslint-disable-next-line complexity, max-statements\n  constructor({\n    // Window width/height in pixels (for pixel projection)\n    width,\n    height,\n    scale,\n    // Desc\n    viewMatrix = IDENTITY,\n    projectionMatrix = IDENTITY\n  } = {}) {\n    // Silently allow apps to send in 0,0\n    this.width = width || 1;\n    this.height = height || 1;\n    this.scale = scale;\n    this.unitsPerMeter = 1;\n\n    this.viewMatrix = viewMatrix;\n    this.projectionMatrix = projectionMatrix;\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // Calculate matrices and scales needed for projection\n    /**\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    const m = createMat4();\n\n    // matrix for conversion from location to screen coordinates\n    mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n\n    mat4.multiply(m, m, this.viewProjectionMatrix);\n\n    const mInverse = mat4.invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n  /* eslint-enable complexity */\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport) {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      mat4.equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      mat4.equals(viewport.viewMatrix, this.viewMatrix)\n    );\n  }\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @return {Array} - screen coordinates [x, y] or [x, y, z], z as pixel depth\n   */\n  project(xyz, {topLeft = true} = {}) {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates,\n   * (possibly [lon, lat]) on map.\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   * @param {Array} xyz - screen coordinates, z as pixel depth\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @param {Object} opts.targetZ=0 - If pixel depth is unknown, targetZ is used as\n   *   the elevation plane to unproject onto\n   * @return {Array} - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject(xyz, {topLeft = true, targetZ} = {}) {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.unitsPerMeter;\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition(xyz) {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.unitsPerMeter;\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz) {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) / this.unitsPerMeter;\n    return [X, Y, Z];\n  }\n\n  /**\n   * Project map coordinates to world coordinates.\n   * This should be overridden by each viewport that implements a specific\n   * geographic projection.\n   * @param {Array} xyz - map coordinates\n   * @return {Array} [x,y,z] world coordinates.\n   */\n  projectFlat(xyz, scale = this.scale) {\n    return xyz;\n  }\n\n  /**\n   * Project world coordinates to map coordinates.\n   * This should be overridden by each viewport that implements a specific\n   * geographic projection.\n   * @param {Array} xyz - world coordinates\n   * @return {Array} [x,y,z] map coordinates.\n   */\n  unprojectFlat(xyz, scale = this.scale) {\n    return xyz;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}